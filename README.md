# C++实习

# 一、    A系统类

## 1.车票管理系统：

**题目要求：**

编程实现车票管理系统，车票信息包括车次号、 发车时间、起始站、终点站、行车时间、载客量、已售票等。

具体实现的管理功能如下： 

（1）录入车次信息（文本文件保存），可随机地增加班次数据。

（2）浏览车次信息，可显示出所有车次当前状态（如果当前时间 超过了某车次的发车时间，则显示“此班已发出”的信息）。

（3）查询路线：可按车次号查询，可按终点站查询

（4）售票和退票功能：情况A：当查询出已售票数小于额定载量且当前

时间小于发车时间时才能售票，自动更新已售票人数；情况B：退票

时，输入退票的车次，当本班车未发出时才能退票，自动更新已售票人

数。 

程序要求： 

（1）  车票的总车次n（n<1000,使用静态数组实现），

（2）  定义两个类：管理系统类和车票车次类

**解题思路：**

定义两个类，车票类和管理类，其中车票类含有车票对应车次的所有信息。管理类负责实现各个功能。

1）录入车次信息：

  1.手动录入：通过控制台来录入车次信息，输入为一个while true

循环，只有当输入数据合法时才会跳出循环。录入完成自动将

所有车票信息导入到文件中

2.文件导入：通过读文件，以及对读入字符串的解析来讲数据

导入到程序中

​           2）浏览车次信息：

​              遍历程序中的所有车票类并将其信息显示到控制台，在显示的

时候进行时间判断，如果发车时间未超过当前时间，便显示发

车时间，反之则显示该车已出发

​         3）查询路线：

1.可按车次号查询：输入车次号，遍历整个车票数组，找到该

车次时停止遍历，并将信息显示到控制台。若未找到，便显

示“未找到该车次信息”

2.可按终点站查询 ：输入终点站，遍历整个车票数组，找到符

合条件的车票类后便将其输出到控制台。

​           4）售票：

​            先将未出发的车次显示到控制台上，然后输入要售票的车次，

对输入的车次进行检查，只有当查询出已售票数小于额定载

量且当前时间小于发车时间时才能售票，自动更新已售票数；

​           5）退票：

​            先将未出发的车次显示到控制台上，然后输入要退票的车次，

对输入的车次进行检查，只有当查询出已售票数大于0且当前

时间小于发车时间时才能售票，自动更新已售票数；

**类的结构：**

**车票类：**

```cpp
class Ticket{

public:

  string Tno;//车次号

  string Time;//发车时间

  string source;//始发站

  string destination;//终点站

  float run_time;//运行时间

  int capacity;//载客量

  int soldTicket;//已售车票

};
```



**管理类：**

```cpp
class SystemManager{

private:

  Ticket tickets[1000];//定义车次类

  int total;//现有车次总数

public:

  SystemManager();//重写构造函数，对各个变量进行初始化

  void showMenu();//展示系统菜单

  void add_ticket();//添加车次信息

  void show_all();//浏览车次信息

  void title();//用于展示表头

  void show_ticket(Ticket);//展示车次信息

  void find_ticket();//查询车票信息

  void sell_ticket();//售票

  void return_ticket();//退票

  void file_in();//文件的导入

  void file_out();//文件导出

};
```



**关键点：**

指定数据的合理存储方案，输入的异常处理，增强程序的健壮性。实现户输入的字符串时间转换为能够与时间戳比较的int类型。整体逻辑的完整性，防止出现不和法的数据。文件存储时各个数据分割所用符号的合理性。避免程序无法正确处理从文件读到的数据。



## 2.学生成绩管理程序：

**题目要求：**

设计一个菜单驱动的学生成绩管理程序。输入学生的基本信息，包括学生的学号、姓名、数学、语文、英语等 信息，实现如下管理功能： 

（1） 能输入并显示n 个学生的基本信息。 

（2） 计算学生的平均分和总分。

（3） 按总分降序进行排序。

（4） 任意输入一个学号，能显示该学生的基本信息。

（5） 可根据需要添加学生信息到指定位置，亦可在最后追加一批学生信

息。

（6）文件的导入和导出（从文件中读取若干条学生信息，或者将学生信

息输出到文件中）。 

（7）注意：学号不能重复；有效成绩的范围为[0,100]

程序要求：

（1）使用C++标准模板库中vector； 

（2）定义两个类：系统类和学生类

**解题思路：**

将学生的各个信息存储到学生类中，对学生的各个操作由系统类来实现，

1）能输入并显示n 个学生的基本信息：将输入语句到一个while（true）循环中，从控制台输入学生的各个数据，并对这些数据进行检验，若输入的数据非法，则重新输入，反之结束循环，将数据构造成一个学生对象加入到学生向量中。

2）计算学生的平均分和总分：将各个学生对象的各科成绩相加，存入到各个对象的总分属性中，再将总分除以科目总数，求得平均分，然后将其存入到各个对象的平均分属性中。

3）按总分降序进行排序：采用冒泡排序算法，将学生向量进行按照总分进行降序排序。

4）任意输入一个学号，能显示该学生的基本信息：先在输入语句出检验输入数据是否合法，直到输入数据合法的时候，遍历学生向量，若找的到对应的学生对象，则显示该学生的信息，若遍历完后未找到，则显示未找到该学生。

5）可根据需要添加学生信息到指定位置，亦可在最后追加一批学生信

息：将数据从控制台输入，检验数据的合法性，只到数据合法的时候，选择添加模式，如果选择添加到尾部，则添加完成后会给出提示信息，若选择添加到指定位置，则需要输入要添加的位置，对位置进行合法性检验，只到位置合法后，进行添加。

6）文件的导入和导出（从文件中读取若干条学生信息，或者将学生信息输出到文件中）。

1. 文件的导出：将学生对象按行导出，即一个学生对象对应一行，改行存有该学生的所有信息，各个信息之间用空格作为分隔。

2. 文件的导入：按行读取文件，将读取到的文件进行解析，若为数值，则将该字符串转为对应的数值。然后用解析后的数据构造一个学生对象，再将这个对象加入到学生向量中。直到文件读取完毕。

7）学号不能重复；有效成绩的范围为[0,100]：

1. 学号不能重复：输入一个学生各个信息后，先对学生向量进行遍历，如果找到了该学号对应的学生，则重新输入。

2. 有效成绩的范围为[0,100]：输入一个学生各个信息后，对各个成绩进行判断，若不合法，则重新输入。

**类的结构：**

**学生类：**

```cpp
class Student{

public:

  string Sno;//学号

  string Sname;//姓名

  int Math_Score;//数学成绩

  int Chinese_Score;//语文成绩

  int English_Score;//英语成绩

  int sum;//总分

public:

Student(string Sno,string Sname,int Math_Score=0,int 

Chinese_Score=0,int English_Score=0);//重写构造函数

};
```

**系统类：**

```cpp
class Manager{

private:

  vector<Student> stus;//定义全体学生

public:

  Manager(vector<Student> stu);//重写构造函数

  void showMenu(); //显示输出菜单

  void create_stu();//1.创建

  void addGrade(); //2.添加

  void average_sumary(); //3.汇总

  void orderBySum(); //4.排序

  void findStu();   //5.查询

  void show_all();  //6.显示

  void file_in();  //7.文件导入

  void file_out(); //8.文件导出

};
```

**关键点：**

数据存储结构的合理构造，数据合法性的判断。合理的文件存储方式。

将从文件读取到的字符串解析为合法的数据。程序整体的逻辑完整性。

# 二、    B 数学类

## 1.空间点、线和面：

**题目要求：**

实现三维解析几何中的点、直线和平面类， 

（1）  能够实现直线的不同创建方式（例如，两个点确定一条直线，两个

相交的平面确定一条直线，空间曲线的点斜式）和平面的不同创建方式（例如，三个不共线的点确定一个平面，一个点和一个法向量确定一个平面）；

（2）  能够计算相应的距离：两点之间的距离，点到直线的距离， 点到平

面的距离； 

（3）  能够计算空间直线的单位方向向量（长度为1），空间平面的单位

法向量（长度为1）； 

（4）  能够判断点和线的关系，线和线的关系，点和平面的关系， 线和平

面的关系，平面和平面的关系。 

（5）  注意：要考虑计算机中实数计算的精度误差（不同精度的数 值相等判断不能使用==）

**解题思路：**

构建向量类，点类，线类，面类。主要是各个类构造函数的实现

1）点的构建：直接输入x,y,z坐标构建

2）直线的构建：

1. 直接输入直线的方向向量和恒过点来构建

2. 两个点确定一条直线：将两点各个坐标对应相减，获得直线的方向向量，然后将第一个点作为直线的恒过点

3. 两个相交的平面确定一条直线：根据两个平面的一般方程，获取对应的法向量，然后将两法向量叉乘得到直线的方向向量，由于直线上一点的坐标必和该直线的方向向量的坐标成比例，则可以得到至少一个方程，然后再将两平面方程与求出方程联立，便能求出该直线的恒过点。

3）面的构建：

1. 直接输入面的法向量和恒过点来构建

2. 三个不共线的点确定一个平面：先对输入的三个点进行不共线判断，若不共线，则将第一个点作为基点，然后和剩下的两个点分别构造向量。将两向量叉乘，得到该面的法向量，基点作为该面的恒过点。

4）计算相应的距离：

​	1.两点之间的距离：直接使用两点之间的距离公式计算

​	2.点到直线的距离：先将该点C映射到直线上，（即直线上x或

​		y或z等于该点对应x或y或z时的点）求得映射点A与该点

​		的距离d1,该点与直线恒过点B的距离d2,构建向量AC和AB,

​		将两向量点乘后再除以d1和d2的积，便得到了AC和AB的

​		余弦值，且d1,d2,h(点到直线的垂线)构成一个直角三角形，则

​		可以h等于d1乘以根号下1与余弦值平方的差。

​	3.点到面的距离：直接使用点到面的距离公式。

5）能够计算空间直线的单位方向向量（长度为1），空间平面的单位法向量（长度为1）；

​	1．能够计算空间直线的单位方向向量：获取直线对象里面的方向向量，然后求出其模，然后各个坐标对于除以模。

​	2．空间平面的单位法向量（长度为1）：获取平面对象里面的法向量，然后求出其模，然后各个坐标对于除以模。

6）能够判断点和线的关系，线和线的关系，点和平面的关系，线和平面的关系，平面和平面的关系。

1. 点和线的关系：将点带入到线的点向式方程中，若等式成立，则点在线上，否则，点在线外

2. 线和线的关系：将两直线的各个系数分别相除，若所得各个系数相等，则两直线平行，反之，相交。

3. 点和平面的关系：将点带入到平面的一般方程中，若等式成立，则点在面上，反之，点在面外。

4. 线和平面的关系：将直线的方向向量与平面的法向量点乘，若为0，则线和面平行，反之线和面相交。

5. 平面和平面的关系：将两平面的法向量各个坐标坐商，若得到的系数是一样的，则两平面平行，反之，两平面相交。

**类的结构：**

点类：

```cpp
class dot{

public:

  float x;//横坐标

  float y;//纵坐标

  float z;//竖坐标

  dot(float x=0,float y=0,float z=0):x(x),y(y),z(z){};//重写构造函

数

  void to_string();//将点转换为字符串输出

};
```

向量类：

```cpp
class Vector{

public:

  float xx;//横坐标

  float yy;//纵坐标

  float zz;//竖坐标

  Vector(float x=0,float y=0,float z=0):xx(x),yy(y),zz(z){};//重写

构造函数

  void to_string();//将向量转换为字符串输出

};
```

平面类：

```cpp
class plane{//采用一般式表示 Ax+By+Cz+D=0

public:

  float a;

  float b;

  float c;

  float d;

  void to_string();//将平面转换为字符串输出

  plane(float a,float b,float c,float d):a(a),b(b),c(c),d(d){};//直接传

参构造

  plane(dot a,dot b,dot c);//三个不共线的点构造一个平面

  plane(dot a,Vector n);//一个点和法向量构造一个平面

  Vector vec();//求单位法向量

};
```



直线类：

```cpp
  class line{//采用点向式表示 (x-x0)/m=(y-y0)/n=(z-z0)/p

public:

  float a;//m

  float b;//n

  float c;//p

  dot X;//(x0,y0,z0)

public:

  line(float a,float b,float c,dot X):a(a),b(b),c(c),X(X){};//直接传参构

造

  line(dot A,dot B);//两点构造一条直线

  line(plane A,plane B);//两平面构造一条直线

  void to_string();//将直线转换为字符串输出

  Vector vec();//求单位方向向量

};
```

普通函数：

```cpp
float distance(type a,type b)//求a到b的距离
float judge(type a,type b)//求a和b的关系
```

**关键点：**

选取合适的表达方程，例如点向式，一般式，点法式等等，判断两个对象之间的关系，找到合适的求距离的方法。坐标为0的处理，要有熟练的空间解析几何功底，不然很难相出点，线和面的构造函数。

## 2.神经网络分类 

**题目要求：**

定义神经网络类Network，属性变量包含数据集的训练次数 epoches、学习

率 learning_rate、网络参数w1、w2、w3、w4、w5、 w6、b1、b2、b3，行

为函数包括构造函数Network、激活函数 sigmoid、激活函数求导

deriv_sigmoid、前向传播函数forward、训练 函数train、预测函数predict，

神经网络结构如下所示



要求：神经网络实现二维点分类，例如：如果x>0，y>0，标签为 0；如果x<0，y<0，标签为1。

**解题思路：**

定义神经网络类，随机生成w1至w6各个权重，然后将文件中的训练数据导入到程序中，通过train函数对该神经网络对象进行训练，其中，用户输入训练次数和学习率，然后程序对训练集中的数据进行计算，求出b3值后，再将其带入到sigmoid激活函数中进行判断，之后求出损失率。再将损失率带入到损失函数中，各个权重分别减去损失函数该点的斜率与学习率的乘积。将调整后的权重再进行训练，直至损失函数取到最小值，或者训练次数结束。至此训练结束。然后用户输入想要判断的点，程序对其进行合法性检验，直到数据合法后，程序调用predict函数，将判断结果显示在控制台上。

**类的结构：**

**训练集点类**：

```cpp
class dot{

public:

  float x1;//横坐标

  float x2;//纵坐标

  int y;//判断值

  dot(float x1=0,float x2=0,int y=0):x1(x1),x2(x2),y(y){};//重写构造函数

};
```

**神经网络类：**

```cpp
class NetWork{

public:

  int epoches;//训练次数

  float learning_rate;//学习率

  float w1,w2,w3,w4,w5,w6;//各个权重

  float b1,b2,b3;//b1 b2为隐含层结点，b3为输出层结点

public:

  NetWork();//重写构造函数

  float sigmoid();//激活函数

  float deriv_sigmoid();//激活函数求导

  float loss(vector<dot>A,vector<dot>B);//损失函数

  void forward(float x1,float x2);//前向传播函数

  void train(vector<dot>A);//训练函数

  int predict(float,float);//预测函数

  void add(float pre,float now);//向后调整权重

  void sub(float pre,float now);//向前调整权重

};
```

**关键点：**

神经网络概念的理解，各个权重初识化大小的范围，训练集的数据是否有代表性，如何求得损失函数某一点的导数值，学习率的大小，训练次数是否合理。找到合适的激活函数。

# 三、    C 游戏类

## 1.猜数字：

**题目要求：**

由计算机随机产生一个1~10000以内的数字，用户根据 提示猜出该数字，功能要求如下：

（1）  游戏结束条件：a）在规定时间内正确猜出该数字；b）规定 用时

耗完。 

（2）  游戏提示：根据用户的输入与所产生数字的大小关系给出正 确提

示，例如，随机产生数为5000，若用户输入6000，则提示“高 了”，若用户输入4000，则提示“低了”。

（3）游戏结果显示：

1）若用户在规定时间内正确猜出数字，则显 示“恭喜！正确猜出数

字***。” 

2）若到达规定时间但并未猜 出，则显示“很遗憾，未能在规定时间

内猜出正确数字，该数字为 ***。” ，其中，“***”表示所需猜出

的随机数。 

（3）  游戏时间设置：可由用户灵活设置游戏时间，此部分内容应 在游

戏开始前完成。 

（4）  游戏退出设置：在每轮游戏结束之后，给出提示语，请用户 选择

是否继续游戏。 

（5）  注意：考虑增加游戏中的趣味性，比如提示特定位上的数字等。

**解题思路：**

首先随机生成一个不超过10000的非零正整数，然后用户输入倒计时的时间，将整个猜数判断写入到一个while(true)循环中，监听键盘是否有输入，若有，则判断输入的数是否为生成的随机数，猜对则结束while循环，猜错则给出提示，每猜错一次便给出一位上数字的提示。若键盘无输入，则进行倒计时操作。判断当前时间是否超过了预定时间。若超时，则结束这个while循环。循环结束后给出提示，询问玩家是否还要再玩一把，若是，则重新生成一个随机数，然后进行猜数操作，若否，则结束整个程序。

**类的结构：**

**随机数生成类：**

```cpp
class Rand_num{

private:

  int rand_num;//随机数

public:

  int create_num();//生成随机数

};
```

**管理类：**

```cpp
class Manager{

public:

  Rand_num R;//随机数生成对象

  int rand_num;//记录生成的随机数

  time_t t;//记录游戏起始时间

  int interval;//倒计时时间

  vector<int> m;//记录各个位上的数值

public:

  void menu();//显示菜单

  void init();//初始化

  void setTime();//设定倒计时

  void tips(int);//提示

  void guess();//判断是否猜对

  void run();//整个猜数字程序的运行

};
```

**关键点：**

如何将计时与猜数并行运行。生成的数字是否合理，太大猜不出来，太小过于容易猜出来。While(true)的合理应用，如何每次给出不同的提示。

## 2.人机下棋：

**题目要求：**

在3×3棋盘上，计算机为一方，用户为一方，交替画 “X”和“O”，在行、列、对角线上谁先练成一条直线谁就获得 胜利。用类的思想完成，具体功能要求如下： 

（1）  状态显示：计算机可正确显示棋盘，给出提示信息和胜负判断

（2）  用户选择：用户可以选择是先下还是后下，并选择棋子是 “X”还

是“O”。 

（3）  每一步都用图形化方式顺序输出，例如



棋盘初始化为（“*”表示空格）



（4）棋盘大小设置：完成上述功能后考虑灵活设置棋盘大小。

（5）注意：可以从积分规则和棋手的下棋策略出发考虑增强程序的智

   能性

提示：解题关键是解决计算机下棋时该下哪个位置，可以用量化的思

想解决该问题。假设计算机用“X”，用户用“O”，计算机下 棋时应考虑

所有空位置，并按照行、列、对角线，算每个空位的分 值，在某行

（列或对角线）上，以下规则进行计分： 

Ø 若已有“XX”，计50分

Ø 若已有“OO”，计25分；

Ø 若已有“X*”，计10分；

Ø 若已有“O*”，计8分；

Ø 如已有“**”，计4分；

其中，“*”表示空格，也可用数字1~9表示空格。以上计分规则仅供参

考

**解题思路：**

先构造电脑玩家类和人类玩家类，两类需要有下棋的函数，以及所选的棋子，其中，电脑玩家类需要有一个判断函数，用于判断自己该将棋子下到哪一个位置，人类玩家的判断则由人脑来实现。构造系统类，其负责让玩家先走还是让电脑先走，玩家选择X还是O,构建棋盘，判断是否有获胜方，显示获胜详情以及记录两玩家各种走的步数。

**类的结构：**

**电脑玩家类：**

```cpp
class com_player{

public:

  char x;//棋子

public:

  void judge(vector<vector<char>> &table);//根据棋盘布局进行判断下子位置

  void run(vector<vector<char>> &table,int count,int &flag);//电脑下棋

};
```

**人类玩家类：**

```cpp
class mu_complayer{

public:

  char x;//棋子

public:

  void run(vector<vector<char>> &table,int n);//玩家下棋

};
```

**系统类：**

```cpp
class Manager{

private:

  com_player p1;//电脑玩家

  mu_complayer p2;//人类玩家

  int n;//棋盘的行列数

  vector<vector<char>> table;//棋盘

  int count1;//记录电脑下棋的步数

  int count2;//记录玩家下棋的步数

public:

  Manager();//重写构造函数

  int judge();//判断是否有获胜方

  void run();//井字棋程序的运行

  void show();//展示棋盘

};
```

**关键点：**

如何实现电脑对于棋子的量化，棋盘的存储结构的设计，对于结果的判定，谁胜谁负，还是平局，各个类如何读取到棋盘信息，并改变棋盘信息。用户输入合法性的检验。

## 3.石头，剪刀，布：

**题目要求：**

设计一个游戏，让用户与计算机玩“石头，剪 刀，布”游戏，要求： （1）程序能够统计玩的次数以及每一次的结果，说明是谁赢了， 还是

   平了；

（2）注意：计算机出牌的最简单的方法是随机算法，请尝试考虑 能不

能设置一种分析用户出牌规律的算法，让计算机能够赢用户的几

率大于50%

**解题思路：**

​    先定义电脑玩家类和人类玩家类，每个类有自己出的拳，以及设定和返

回拳值的函数，其中电脑玩家类有一个判断函数，用于分析自己该出什么

拳。判断函数可采用量化的方法，电脑统计玩家的出各个拳的次数，输了对

应拳的次数要乘2.平局对应拳的次数乘1，赢了对应拳的次数减1。然后找

出玩家最爱出的拳，电脑出反制它的拳。系统类便负责判断两者谁赢还是平

局，以及是否再比一局。

**类的结构：**

​     **电脑玩家类：**

```cpp
  class com_player{

private:

  char value;//计算机出的值

public:

  void guess(map<int,string>);//根据每次猜拳结果进行分析该出的拳

  void set_value(map<int,string>);//设定出的拳

  char get_value();//获取出的拳

};
```

**人类玩家类：**

```cpp
class hum_player{

private:

  char value;//人类玩家出的拳

public:

  void set_value();//设置出的拳

  char get_value();//获取出的拳

};
```

**管理类：**

```cpp
class Manager{

private:

  com_player p1;//电脑玩家

  hum_player p2;//人类玩家

  map<int,string>reme;//每次输赢对应的值

  int n;       //记录玩的次数

  int f0;       //记录电脑获胜次数

  int f1;       //记录玩家获胜次数

  int f2;       //记录平局次数

public:

  void init();//初始化猜拳程序

  void run();//运行猜拳程序

  void play();//判断电脑和玩家出的拳压制关系

};
```

**关键点：**

​    电脑如何分析玩家的出拳规律。玩家输入的合法性判断。如何实现对结果的判断，谁胜谁负，还是平局。将石头剪刀布映射为合适的数据类型，存入程序

# 四、    D 链表类

## 1．整数链表：

**题目要求：**

要求编程实现整数链表类，实现以下功能： 

（1）链表的创建。

（2）插入结点，要能在所有可能的位置上插入结点。

（3）删除节点。

（4）链表遍历输出。

（5）实现结点的查询

（6）注意：考虑用类模板实现通用的链表类

**解题思路：**

先定义结点类，其包括数据域和指针域。然后再定义链表类。

1）判断链表是否为空：检查头结点的指针域是否为空，若为空则链表为空，反之则不为空

2）获取链表的长度：定义一个结点指针，从首元结点开始遍历，若其指向的结点指针域不为空，则计数变量加一，反之，返回计数变量的值

3）插入元素：

1. 默认插入表头：将传入的元素生成一个结点对象，然后将其指针域指向首元结点的指针域指向的结点，再将首元结点的指针域指向该结点

2. 在链表的指定位置插入元素：先对插入位置进行合法性检验，合法后，生成一个指向首元结点的结点指针，然后用这个指针遍历该链表，直到到达要插入的位置，将传入的元素生成一个结点对象，其指针域指向遍历指针指向的结点，然后遍历指针指向的结点的指针域再指向该结点。

4）删除元素：

1．默认删除链表的第一个元素，并返回该元素：定义一个指向首元结点的指针q,将头指针的指针域指向的结点改为q指向结点的指针域指向的结点，然后释放q指向结点的内存空间。

2．删除并返回指定位置的元素：先进行位置合法性判读，若合法，定义一个指向首元结点的指针q，一个指向头结点的指针p,两指针同时遍历链表，当q到达指定位置时，p指向结点的指针域指向的结点改为q指向结点的指针域指向的结点。然后，将q的数据域返回，最后释放q指向结点所占内存。

5）查找元素：

1. 找出并返回指定位置的元素：先对输入位置合法性进行检验，若合法，定义一个指向首元结点的指针，然后开始遍历整个链表，直到指定位置，然后将该位置结点的数据域返回。

2. 找到并返回传入元素的位置：定义一个指向首元结点的指针，然后开始遍历整个链表，若找到数据域符合要求的结点，返回该结点在链表的位置。结束遍历。若遍历完后未找到，则返回-1。

6）遍历整个链表：定义一个结点指针，从首元结点开始遍历，若其指向的结点指针域不为空，则输出该结点的数据域，直到指针指向结点的指针域为空。

**类的结构：**

**结点类：**

```cpp
template <typename T>

class Node {

public:

  /* 用于链表节点的定义 */

  T data; // 表示数据域

  Node<T> *next; // 表示指针域，存储下一个节点的位置

};
```

**链表类：**

```cpp
template <typename T>

class LinkList : public Node<T>{

private:

  /* 用于链表的定义 */

  Node<T> *head; // 头节点

public:

  /* 成员函数的声明 */

  LinkList(); // 重写默认的构造函数

  bool Empty(); // 判断链表是否为空

  int GetLen(); // 获取链表的长度

  void insert(T elem); // 默认插入链表的开头

  bool insert(int idx, T elem); // 在链表的指定位置插入元素

  T remove(); // 默认删除链表的第一个元素，并返回该元素

  bool remove(int idx, T &elem); // 删除并返回指定位置的元素

  bool index(int idx, T &elem); // 找出并返回指定位置的元素

  int index(T elem); // 找到并返回传入元素的位置

  void traverse(); // 用于遍历整个链表

};
```

**关键点：**

​    数据结构的合理指定，输入位置的合法性检验，函数模板的正确使用，指针的灵活运用，结点所占内存空间的及时释放。类的继承。

## 2.错题本管理程序：

利用链表实现错题本管理程序。其中错题信息 包括题目、错误信息、答案分析、心得体会、错题来源、错题原 因、难易程度、题目类型、知识点等多项信息。具体实现的管理功 能如下： 

（1） 输入并显示错题的信息； 

（2） 可实现错题信息的添加； 

（3） 查询（至少提供按知识点和题目类型两种方式）；

（4） 修改（提供查询后进行修改）；

（5） 删除（依据指定的信息（知识点和题目类型）查找后删除错 题）； （6）文件的导入和导出（从文件中读取若干条错题信息，或者将 错题信息

输出到文件中）。 

（7）注意：考虑实现标签分类管理以提高操作效率。 

（8）注意：修改、删除操作均在查找后完成，如查找后存在多条 记录符合

条件，考虑如何进行选择操作 程序所显示的菜单基本内容如下

程序所显示的菜单基本内容如下：



**解题思路：**

​    先定义错题结点类，其包括数据域和指针域。然后再定义管理类。管理类继承错题结点类，其包含三个链表，分别对应选择题，填空题和判断题。

1）添加错题信息：从控制台输入错题信息，然后对其进行合法性检查，若合法，则生成对应的错题结点，然后提取错题结点的难度类型属性，根据难度类型，将该结点加入到对应的链表中。

2）浏览错题信息：三个链表依次遍历，将结点信息输入到控制台。

3）查询错题信息：先选择查询方式，是按题目类型查还是按知识点查

1. 按题目类型查：输入对应的题目类型，然后遍历对应的链表，将信息输出到控制台

2. 按知识点查：依次遍历三个链表，若找到符合要求的结点，便将其信息输出到控制台。

4）删除错题信息：先将选择要删除错题的类型，再将该类错题展示到控制台，然后输入要删除错题的编号进行删除，当输入错题编号合法时才能进行删除操作。

5）文件导入：定义文件流对象，文件按行读取，将读取到的字符串进行覆盖，类型转换，然后将这些数据构造成一个错题结点，再将此节点添加到对应的链表中。

6）文件导出：定义文件流对象，将一个错题结点的各个数据用‘#’分割，最后再加上一个换行符，然后组成一个字符串，将此字符串写入到文件中。直到将所有的错题结点都写入到文件中。

**类的结构：**

**错题结点：**

```cpp
class Node {

public:

  /* 用于错题节点的定义 */

  int No;      //题目编号

  string title;   // 题目

  string er_msg;  //错误信息

  string answer;  //答案分析

  string experience;//心得体会

  string source;  //错题来源

  string reason;  //错题原因

  string rank;    //难易程度

   int type;   //题目类型 选择题：2 判断题：1 填空：0

  string point;  //知识点

  Node *next;   // 表示指针域，存储下一个节点的位置

};
```

**管理类：**

```cpp
class Manager : public Node{

private:

 

  Node *head2; // 难题头节点

  Node *head1; // 适中题头节点

  Node *head0; // 简单题头节点

public:

  /* 成员函数的声明 */

  Manager(); // 重写默认的构造函数

  void Menu();//显示菜单

  void add();//添加错题

  void show(Node *head,int flag);//flag传给to_string方法

  void traverse();//遍历错题

  void find(int);//查找错题

  void update();//修改错题

  void remove();//删除错题

  void file_in();//文件的导入

  void file_out();//文件导出

  void to_string(Node *p,int flag=0);//0表示展示题目类型，不展示知识点；1表示展示知识点，不展示题目类型

};
```

**关键点：**

数据结构的合理制定，输入数据的合法性检验，文件存储格式的合理制定，查找方式的选择。While(true)的合理应用。链表的正确使用。

## 3.约瑟夫退圈问题：

**题目要求：**

利用循环链表类实现约瑟夫退圈问题：n 个人 （不同 id）围成一个圈，从 startId(任意数)个开始报数 m(任意数)个 数，数 m 的人出列排成新队列，m 清零，然后又从下一个人开始数 m 个数开始，数到 m 就出列接在新队列尾部，如此重复，直到所有 人都出列为止，请输出出列的次序（依次输出出列人员的编号）。

说明：参数n，stratId和m要通过输入确定，注意要考虑startId和m 大于n的情况。

**解题思路：**

先定义链表结点类，其中包括数据域和指针域，再定义循环列表类。

1）重写构造函数：申请头结点的内存空间，然后将头结点的指针域指向自己。

2）插入元素：采用尾插法，定义一个指向链表“尾部”的结点指针，然后将新结点的指针域指向头结点，“尾部”的结点指针所指向结点的指针域指向新结点

3）删除指定位置的结点并返回元素：定义一个指向头结点的结点指针p和指向首元结点的结点指针q,两指针同时遍历链表，直到q指针到达指定位置，将p所指向结点的指针域指向q所指向结点。然后将*q的数据域返回，最后释放q指向结点所占内存。

4）查找元素：定义一个指向首元结点的指针，然后开始遍历整个链表，若找到数据域符合要求的结点，返回该结点在链表的位置。结束遍历。若遍历完后未找到，则返回-1。

5）遍历整个链表：定义一个结点指针，从首元结点开始遍历，若其指向的结点指针域所指结点不为头结点，则输出该结点的数据域，直到指针指向结点的指针域所指结点为头结点。

约瑟夫退环问题处理：

先输入人数n，程序从1开始为每个人设置id,然后输入standId,判断standId是否大于人数n或者小于1,若违反规定，则重新输入，直到输入合法，然后程序找到该Id对应的结点的前一个结点。用指针pre指向它，然后输入报数上限m，从该结点开始循环遍历链表m-1次，循环结束后，定义结点指针q，其指向pre的下一个结点，即要出队的结点，将pre的下一个结点指向q的下一个结点，然后将q从链表中删除，再将其加入到输入链表中。若链表不为空，则再次执行输入报数上限m之后的操作，直至链表为空。然后输入退圈序列。

**类的结构：**

**整数结点类**：

```cpp
class Node {

public:

  /* 用于链表节点的定义 */

  int data; // 表示id

  Node *next;  // 表示指针域，存储下一个节点的位置

};
```

**循环链表类**

```cpp
class LinkList : public Node{

public:

  /* 用于链表的定义 */

  Node *head; // 头节点

public:

  /* 成员函数的声明 */

  LinkList(); // 重写默认的构造函数

  bool Empty(); // 判断链表是否为空

  int GetLen(); // 获取链表的长度

  void insert(int elem); // 默认插入链表的尾部

  bool insert(int idx, int elem); // 在链表的指定位置插入元素

  int remove(); // 默认删除链表的最后一个元素，并返回该元素

  bool remove(int idx, int &elem); // 删除并指定位置的元素

  bool index(int idx, int &elem); // 找出并返回指定位置的元素

  int index(int elem); // 找到并返回传入元素的位置

  void traverse(); // 用于遍历整个链表

};
```

**关键点：**

循环链表的使用，输入数据合法性的检验，尾插法的使用，指针的正确使用，队列的正确使用。

